import asyncio
import json
import logging
from typing import List, Dict

from chess import Board, Piece, Move, InvalidMoveError, IllegalMoveError, AmbiguousMoveError, WHITE, BLACK
import websockets
import interactions

from config import ENGINE_HOST, ENGINE_PORT, ENGINE_PW, ENGINE_USER, DEFAULT_GAME_OPTIONS, DEFAULT_CLIENT_OPTIONS
from game_session import GameSession, correct_bad_move, disambiguate_move
from client_options import ClientOptions
import flavor_strings
from flavor_strings import checkmate_1p, stalemate_1p, draw_1p, checkmate_2p, checkmate_2p_upset, draw_2p, \
    stalemate_2p, resign_2p, interloper
    # checkmate_string, stalemate_string, draw_string, resign_string, interloper_string, \
    # illegal_move_string, invalid_move_string, ambiguous_move_string, check_string, move_string, \
    # game_over_string, game_start_string, game_cancel_string, game_cancelled_string, game_cancel_fail_string, \
    # game_cancel_fail_not_found_string, game_cancel_fail_not_your_turn_string, game_cancel_fail_not_your_game_string, \
    # game_cancel_fail_not_started_string, game_cancel_fail_not_in_progress_string, game_cancel_fail_not_finished_string, \
    # ai_game_start_string, ai_game_cancel_string, ai_game_cancelled_string, ai_game_cancel_fail_string, \
    # ai_game_cancel_fail_not_found_string, ai_game_cancel_fail_not_your_turn_string, ai_game_cancel_fail_not_your_game_string, \
# Those were all generated by Copilot and might not be implemented, but I'm leaving them there for inspiration.
    

logger = logging.getLogger(__name__)

# Map pieces to emoji names
pieces_map = {
    'P': 'pw',
    'R': 'rw',
    'N': 'nw',
    'B': 'bw',
    'Q': 'qw',
    'K': 'kw',
    'p': 'pb',
    'r': 'rb',
    'n': 'nb',
    'b': 'bb',
    'q': 'qb',
    'k': 'kb',
    '.': '__'
}

# Map emoji names to emoji references, e.g. 'pw' -> '<:pw:1084899251366133802>'
# Must be initialized after the bot is logged in, since the emoji IDs change whenever the server's emojis are updated
# TODO: just use a single map for both pieces_map and emoji_map, this is silly
emoji_map = {}

def populate_emoji_map(new_map: Dict[str, str]):
    '''Populate emoji_map with the current emoji references.'''
    for piece, emoji in new_map.items():
        emoji_map[piece] = emoji
    logger.debug(f'Populated emoji_map in client_game_session.py: {emoji_map}')

def fen_to_emoji(fen: str) -> str:
    '''Given a FEN string, return a string that can be used in a Discord message'''
    board = Board(fen)
    return board_to_emoji(board)

def board_to_emoji(board: Board, moves_list: List[str]=None) -> str:
    '''Given a board from chess.py, return a string that can be used in a Discord message,
    e.g. given a board with the starting position, return:
    [list of moves, blank in this case]
    :rbl::nbd::bbl::qbd::kbl::bbd::nbl::rbd: `8`
    :pbd::pbl::pbd::pbl::pbd::pbl::pbd::pbl: `7`
    :__l::__d::__l::__d::__l::__d::__l::__d: `6`
    :__d::__l::__d::__l::__d::__l::__d::__l: `5`
    :__l::__d::__l::__d::__l::__d::__l::__d: `4`
    :__d::__l::__d::__l::__d::__l::__d::__l: `3`
    :pwl::pwd::pwl::pwd::pwl::pwd::pwl::pwd: `2`
    :rwd::nwl::bwd::qwl::kwd::bwl::nwd::rwl: `1`
    ` a  b  c  d  e  f  g  h  `
    Not quite like that, each emoji will be a fully-qualified reference, e.g. <:pwl:1084899251366133802>,
    but that would be too long for this comment.
    '''
    # If moves_list is None, try to get the moves from the board
    if moves_list is None:
        moves_list = board.move_stack
    # Get the last move, if any
    last_move = moves_list[-1] if len(moves_list) > 0 else None
    # Get a string representation of the moves list
    if len(moves_list) == 0:
        moves_str = ''
    else:
        # Add move numbers every other move, and with the last move wrapped with '**'
        moves_str = ''.join([(f'  {i // 2 + 1}. ' if i % 2 == 0 else ' ') + f'{"**" if i == len(moves_list) - 1 else ""}{move.uci()}' for i, move in enumerate(moves_list)]) + '**'
    # Get a representation of the board as a 2D array
    board_str = str(board)
    board_arr = [rank.split(' ') for rank in board_str.split('\n')]
    # Isolate the relevant squares from the last move, if any, for highlighting
    (fr, ff, tr, tf) = (7 - last_move.from_square // 8, last_move.from_square % 8, 7 - last_move.to_square // 8, last_move.to_square % 8) if last_move else (None, None, None, None)
    # Convert to a 2D array of emoji names
    board_arr = [[f'{pieces_map[board_arr[r][f]]}{"h" if ((r == fr and f == ff) or (r == tr and f == tf)) else ("l" if (r + f) % 2 == 0 else "d")}' for f in range(len(board_arr[r]))] for r in range(len(board_arr))]
    # Convert the board array into a list of strings, each string representing a rank
    ranks_arr = [' ' + ''.join([emoji_map[p] for p in board_arr[r]]) + f' `{8-r}`' for r in range(len(board_arr))]
    # Add the move list as an initial string
    ranks_arr.insert(0, moves_str)
    # Add the file labels as a final string
    ranks_arr.append('` a  b  c  d  e  f  g  h  `')
    # Join the lines into a single string and return it
    return '\n'.join(ranks_arr)

def emoji_to_fen(emoji: str) -> str:
    '''Given a string that can be used in a Discord message, return a FEN string'''
    # Get the board from the emoji
    board = emoji_to_board(emoji)
    # Return the FEN string
    return board.fen()

def emoji_to_board(message_str: str) -> Board:
    '''Given a string that can be used in a Discord message, return a chess.Board'''
    # Create a new board
    board = Board()
    # Discard the first line (the move list) if it exists (starts with '1. ')
    if message_str.split('\n')[0].startswith('1. '):
        message_str = '\n'.join(message_str.split('\n')[1:])
    # Discard the last line (the file labels) if it exists (starts with '` a ')
    if message_str.split('\n')[-1].startswith('` a ') or message_str.split('\n')[-1].strip().startswith('a'):
        message_str = '\n'.join(message_str.split('\n')[:-1])
    # Discard the file labels at the end of each line if they exist
    message_str = '\n'.join([line.strip().split(' ')[0] for line in message_str.split('\n')])
    # Get the ranks from the emoji
    ranks = message_str.split('\n')
    if len(ranks) != 8:
        print(f'Invalid number of ranks: {len(ranks)}')
        print(f'Ranks: {ranks}')
        raise ValueError('Invalid number of ranks')
    # Iterate over the ranks
    for r in range(len(ranks)):
        # Get the squares from the rank
        squares = ranks[r].split('::')
        # Iterate over the squares
        for f in range(len(squares)):
            # Get the piece from the square
            emoji = squares[f].replace(':', '')
            piece = emoji[0].upper() if emoji[1] == 'w' else emoji[0]
            # If the square is not empty, add the piece to the board
            if piece != '_':
                board.set_piece_at((7 - r) * 8 + f, Piece.from_symbol(piece))
    # Return the board
    return board

def moves_to_board(moves: str) -> Board:
    '''Given a string of moves, return a chess.Board'''
    # Create a new GameSession (useful for parsing moves)
    game_session = GameSession()
    for move in moves.split(' '):
        if not game_session.push_move_str(move):
            print(f'Invalid move: {move}')
            raise ValueError('Invalid move')
    return game_session.board

def moves_to_fen(moves: str) -> str:
    '''Given a string of moves, return a FEN string'''
    # Get the board from the moves
    board = moves_to_board(moves)
    # Return the FEN string
    return board.fen()

# TODO: maybe subclass this into two classes (player-vs-engine games and player-vs-player games)
class ClientGameSession(GameSession):
    '''
    A GameSession that can be used to connect to a chess engine, or handle a game between two human players.
    Includes a websocket connection to the engine, and a session ID for the engine to identify the game.
    game_options includes the options that are relevant to both the client and the engine; see the GameSession class for details.
    client_options includes only the options that are relevant to the client; see the ClientOptions class for details.
    '''
    def __init__(self, client_options: ClientOptions, fen: str=None, moves: list=[], game_options: dict=DEFAULT_GAME_OPTIONS):
        super().__init__(fen, moves, game_options)
        self.client_options = client_options
        self.flavor_state = {
            # Various state information for providing more fun flavor text
            'spectators': [], # Discord IDs of spectators
            'interlopers': {}, # Discord IDs of players who have attempted to join the game but are not allowed to, mapped to flavor text generators (TODO)
        }
        # If the game is vs the engine, connect to the engine
        if self.client_options.players == 1:
            # TODO: sort out once and for all whether session_id comes from the engine or the client.
            # Also stop coding this late at night.
            # For now I'm going to assume that the client generates the session ID and sends it to the engine.
            # The engine will then send the session ID back to the client.
            # The client will then send the session ID to the engine when it makes a move.
            # This is ridiculous. I'm going to bed.
            self.ws = None
            asyncio.run(self.connect()) # Is this the right way to do this?
    
    def __str__(self):
        '''Return a string representation of the game.'''
        # Get the author's id
        author_name = self.client_options.author_id
        # Get the opponent's id
        opponent_name = self.client_options.opponent_id
        # Get the game's name
        name = self.client_options.name
        # Get the list of moves
        moves = self.moves
        return f'GameSession({author_name}, {opponent_name}, {name}, {moves})'
    
    def new_game(self):
        '''
        Start a new game.
        '''
        author_nick = self.client_options.author_nick
        opponent_nick = self.client_options.opponent_nick
        author_color = 'white' if self.client_options.author_is_white else 'black'
        ret_str = f'New game started between {author_nick} ({author_color}) and {opponent_nick}.\n'
        ret_str += self.get_last_move_response()
        return ret_str

    def make_move(self, move_str: str, move_author: interactions.Member) -> str:
        '''
        After running various checks, make a move.
        Verify the author of the move, send the move to the engine, display the move on the board, ping the opponent, and update the clock.
        It's the caller's responsibility to verify that this GameSession corresponds to the channel in which the move was made.
        '''

        # TODO: replace all these with flavor text in flavor_strings.py
        if move_author is None:
            return 'Something went wrong on the backend. I don\'t even know who you are.'
        
        if move_author.user.id != self.client_options.black_id and move_author.user.id != self.client_options.white_id:
            return f'You are not a player in this game, {move_author.nick}.'
        
        elif move_author.user.id != self.client_options.white_id and self.turn == WHITE:
            return f'It is not your turn, {move_author.nick}!'
        
        elif move_author.user.id != self.client_options.black_id and self.turn == BLACK:
            return f'It is not your turn, {move_author.nick}!'
        
        # Check the move for validity
        try:
            move = self.parse_move(move_str)

        except (InvalidMoveError, IllegalMoveError):
            suggestions = correct_bad_move(move_str, self.board)
            if suggestions and len(suggestions) > 1:
                return f'Invalid move \'**{move_str}**\'! Did you mean one of these? [**{"**, **".join(suggestions)}**]'
            elif suggestions and len(suggestions) == 1:
                return f'Invalid move \'**{move_str}**\'! Did you mean **{suggestions[0]}**?'
            else:
                return f'Invalid move \'**{move_str}**\'! Did you mean to type `/resign`?'
            
        except AmbiguousMoveError:
            suggestions = disambiguate_move(move_str, self.board)
            if suggestions and len(suggestions) > 2:
                # e.g. "Did you mean x, y, or z?"
                return f'Ambiguous move \'**{move_str}**\'! Did you mean **{"**, **".join(suggestions[:-1])}**, or **{suggestions[-1]}**?'
            elif suggestions and len(suggestions) == 2:
                # e.g. "Did you mean x or y?"
                return f'Ambiguous move \'**{move_str}**\'! Did you mean **{suggestions[0]}** or **{suggestions[1]}**?'
            elif suggestions and len(suggestions) == 1:
                # This should never happen, but just in case...
                return f'Ambiguous move \'**{move_str}**\'! Did you mean **{suggestions[0]}**?'
            logger.error(f'No suggestions for ambiguous move {move_str}!')
            return f'Ambiguous move \'**{move_str}**\'! I don\'t know what you mean.'
        
        # If the move is valid, make it
        self.push_move(move)
        
        # If the game is vs the engine, send the move to the engine
        if self.client_options.players == 1:
            self.send_move(move)

        # Get additional information about the move
        check_warning_str = self.check_warning(move_str)

        # Return a string showing the moves, the board, and the move info
        ret_str = self.get_last_move_response(check_warning_result=check_warning_str)
        return ret_str
    
    def get_last_move_response(self, author_nick: str = None, check_warning_result: str = None) -> str:
        '''
        Get the response to the last move on the board stack.
        This includes the move itself (if one was made), the board, and (maybe) a warning about check.
        '''

        last_move_str = self.last_move if self.client_options.notation == "san" else self.board.move_stack[-1].uci() if len(self.board.move_stack) > 0 else None

        ret_str = ''

        # Note the move if one was made and the author's name is known
        if last_move_str and author_nick:
            ret_str += f'{author_nick} plays **{last_move_str}**.\n'

        # Convert the board to emoji, sending the list of SAN-formatted moves if the notation is SAN
        if self.client_options.notation == 'san':
            ret_str += board_to_emoji(self.board, self.moves)
        elif self.client_options.notation == 'uci':
            ret_str += board_to_emoji(self.board)

        # Add any game state info from the last move
        if check_warning_result:
            ret_str += f'\n**{check_warning_result}**'

        if self.is_game_over:
            if self.is_checkmate:
                winner = self.client_options.white_nick if self.turn == BLACK else self.client_options.black_nick
                loser = self.client_options.white_nick if self.turn == WHITE else self.client_options.black_nick
                ret_str += f'\n{next(checkmate_2p if self.client_options.players == 2 else checkmate_1p).format(winner=winner, loser=loser)}'
            elif self.is_stalemate:
                ret_str += f'\n{next(stalemate_2p if self.client_options.players == 2 else stalemate_1p)}'
            # No need to do anything else; caller will check if the game is over as well

        else: # No need to ping if the game is over
            # TODO: add flavor text here too
            if self.client_options.ping_white and self.turn == WHITE:
                ret_str += f'\n <@{self.client_options.white_id}>, it\'s your turn!'
            elif self.client_options.ping_black and self.turn == BLACK:
                ret_str += f'\n <@{self.client_options.black_id}>, it\'s your turn!'

        return ret_str

    def send_move(self, move_str: str) -> None:
        '''
        Send a move to the engine.
        '''
        raise NotImplementedError
        self.ws.send(json.dumps({'request': 'move', 'session_id': self.session_id, 'move': move_str}))    
    
    async def connect(self):
        connection_string = f'wss://{ENGINE_USER}:{ENGINE_PW}@{ENGINE_HOST}:{ENGINE_PORT}'
        self.ws = await websockets.connect(connection_string)
        await self.ws.send(json.dumps({'request': 'new', 'game_options': self.game_options}))
        response = json.loads(await self.ws.recv())
        if response['code'] != 200:
            logger.error(f'Failed to connect to engine: {response["message"]}')
        else:
            self.session_id = response['session_id']
            self.connected = True

    async def disconnect(self):
        await self.ws.send(json.dumps({'request': 'exit'}))
        await self.ws.close()
        self.connected = False
    
    def to_json(self) -> dict:
        '''
        Convert the game to a JSON object.
        '''
        return {
            'board': self.board.fen(),
            'last_move': self.last_move,
            'game_options': self.game_options,
            'client_options': self.client_options,
            'session_id': self.session_id,
            'connected': self.connected
        }
